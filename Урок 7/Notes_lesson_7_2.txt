УРОК 7. ЧАСТЬ 2. МЕТОДЫ ПЕРЕБОРА МАССИВОВ 

const books = [
    {id = 0, name: 'Дорога домой', author: 'Виталий Зыков', price: 1200},
    {id = 1, name: 'Война за выживание', author: 'Виталий Зыков', price: 1500},
    {id = 2, name: 'Мир бесчисленных островов', author: 'Алекс Кош', price: 950},
    {id = 4, name: 'Адреналин', author: 'Алекс Кош', price: 1650},
]



Добавление и удаление массивов CONCAT 

 Возвращает НОВЫЙ массив на основе исходного и добавляет объекты 

const newArr = books.concat({id = 5, name: 'Школа пепла', author: 'Виталий Зыков', price: 1980})

console.log(newArr)
 
МЕТОД SLICE([start], [end])

возвращает новый массив на основе исходногоБ начиная с идекса старт и заканчивая индексом энд

const newArr = books.slice(0,3)
console.log(newArr)


начиная с индекса 0, заканчтвая индекс 3 НЕ ВКЛЮЧАЯ ЕГО 



МЕТОД SPLICE(index, deleteCount, elements) 

универсальный ножик
может то, что 2 метода выше

НЕ ВОЗВРАЩАЕТ НОВЫЙ МАССИВ, А МЕНЯЕ СТАРЫЙ!
 
books.splice(2,3) //начиная со второго индекса удаляет 3 элемента

console.log(books)

ЧТОБЫ ДОБАВИТЬ ЭЛЕМЕНТ
третьим параметром ввести что добавляем 1 или несколько элементов

books.splice(2,3, {id = 1, name: 'Школа пепла', author: 'Виталий Зыков', price: 1800},)
console.log(books)

ПОИСК ЭЛЕМЕНТОВ В МАССИВЕ find 
find принимает в себя callback, который в свою очередь принимает 3 аргумента 
item - очередной элемент при итерации
index - его индекс 
array - сам массив

//let result = arr.find(function(item, ndex, array)){
    //если true - возвращается текущий элемент и перебор прекращается 
    если false - если все итерации оказались ложными, то вернется undefined
}


 Пример
const result = books.find(function(item, index, array){
    return item.name === 'Война за выживание'
})
console.log(result)
 
! FIND возвращает целый объект, найденный по условиям

МЕТОД findIndex 
вернет только индекс этого элемента в МАССИВЕ

 const result = books.findIndex(function(item, index, array){
    return item.name === 'Война за выживание'
})
console.log(result)


МЕТОДЫ ПЕРЕБОРА 

синтаксис похож 
принимают аргументом callback, который в свою очередь принимает при итерации, его индекс и весь перебираемый массив 


1) FOREACH()
перебирает весь массив и для каждого элемента массива по очереди вызывает callback  
МЕНЯЕТ ИСХОДНЫЙ МАССИВ, НОВЫЙ НЕ СОЗДАЕТ !

 .forEach(function(item)){
    item.price = item.price + 'руб'
}
console.log(books)

 2) МЕТОД map
 let result = arr.map(function(item, index, array ))
создает новый массив, на каждой итерации заменяя наши элементы 
можно собрать новый объект на основе старого и укказать свойства, которые нам нужны 

const books = [
    {id = 0, name: 'Дорога домой', author: 'Виталий Зыков', price: 1200},
    {id = 1, name: 'Война за выживание', author: 'Виталий Зыков', price: 1500},
    {id = 2, name: 'Мир бесчисленных островов', author: 'Алекс Кош', price: 950},
    {id = 4, name: 'Адреналин', author: 'Алекс Кош', price: 1650},
]

const newArr = books.map(function(item){
     item.price = item.price + 'руб'
    return item 
})

 3) МЕТОД filter 
 создает новый массив 
 записывает туда только те жлементы, которые прошли проверку, условие 

   const newArr = books.filter(function(item){
    return item.author ===  'Виталий Зыков'
   })

   console.log(newArr)

   Если возвращает истинное значение, то включается в новый массив, если нет - нет  


 4) МЕТОД REDUCE 

 let.value = arr.reduce(function(previousValue, item, index, array){
    .....
 }, [initial])
 последовательная обработка

пример - надо собрать цену всех товаров в 1 контейнер и сделать сумму (корзина)

const result = books.reduce(function(sum, item){
    return sum +item.price
},0)

  console.log(result  )


принимает аргументом callback и второй аргумент - число, с которого начнутся все расчеты. // В данномт случае - 0. Но его по условию можно поменять. например для умножения была бы 1  

первый аргумент - контейнер, в который будет скоадироваться вся сумма. Остальное (2 аргумента), как в прошлом примере 

На первом круге sum будет равна тому числу, которое указали ниже - 0


5) МЕТОД reduce.Right
работает как и reduce, только справа налево  
!неважно в сложении, но важно в умножении

  
