  
АТТРИБУТ НА САМОМ ЭЛЕМЕНТЕ

Вешаем на кнопку attribute on click, внутрь кавычек передаем то действие, которое должно произойти 
НО! Способ устаревший. JS не вносим в html
...
<button onclick= "alert('Клик по кнопке')" id="btn"
...

СВОЙСТВО onclick

const btn = document.getElementById('btn')

btn.onclick = function (){
    alert('Клик по кнопке!')
}

console.dir(btn);

Вообще нельзя повесить 2 функции на обработчик события onclick. 
Если назначить вторую функцию, то первая просто затрется.

const square = document.getElementsById('square')

const logger = function(){
    console.log('Клик по квадрату')
}

square.onclick = logger
console.dir(square);


СПОСОБ, КАК ЗАПУСТИТЬ СРАЗУ 2 функции

ВЫЗЫВАЕМ АНОНИМНУЮ ФУНКЦИЮ, КОТОРАЯ ВЫЗЫВАЕТ 2 ДРУГИЕ

square.onclick = function() {
    logger()
    logger1()
}
 console.dir(square)

 Как удалить обработчик - затереть значение свойства onclick - 
 square.onclick = null = // Затираем значение. При нажатии - ничего не выдаст 

ПЕРЕОПРЕДЕЛИТЬ СВОЙСТВО
неустаревший, использкется в нащии днив


 square.onclick = function() {
    logger()
}


МЕТОД AddEventListener('...','...')
Принимают на обработку любое количество функций
более фукнкциональный

const square = document.getElementById('square')

const logger = function (){
    console.log('Клик по квадрату');
}

square.AddEventListener('click', logger)// Получаем клик по квадрату


УДАЛИТЬ СЛУШАТЕЛЬ - МЕТОД .removeEventListener

square.removeEventListener('click', logger)// удалит слушатели 

Ньюанс: не сможем удалить анонимную функцию, если повесим ее на обработу событий клик

Удалять можем только именные функции
Имя функции выступает как ключик для удаления

ОБЪЕКТ Event
Каждая call-back функция, которая передается в метод AddEventListener, 
получает внутри данного метода доступ к самому событию, к объекту данного события 
и принимает его в первый параметр 

Принято записывать как Event или E 

Если выведем, то получим объект, в котором будет вся информация о событии

const square = document.getElementById('square')

const logger = function (event) {
    console.log(event);
}

square.AddEventListener('click', logger)


СОБЫТИЯ МЫШИ 

1) mouseup
2) mousedown
3) mousemove


click это совокупность 2 событий, mouseup
и mousedown

Запись: 


square.AddEventListener('click', logger)
square.AddEventListener('mouseup', logger)
square.AddEventListener('mousedown', logger)
square.AddEventListener('mousemove', logger) // реагируют на движение мыши

4) mouseenter
5) mouseleave 
square.AddEventListener('mouseenter', logger)
square.AddEventListener('mouseleave', logger) // заходит и покидает пределы фигуры 

6) mouseover
7) mouseout

square.AddEventListener('mouseover', logger)
square.AddEventListener('mouseout', logger)

События over и out реаагируют на вложенные элементы, 
enter и leave четко реагируют по тому элементу, 
на который навешен обработчик события и не реагируют на вложенные элементы 

Так можно находить границы внутри элемента с его дочерними элементами или просто их игнорировать 

СОБЫТИЯ ПРИ РАБОТЕ С ФОРМАМИ 

input

const text = document.getElementById('text')
const logger = function(event){
    console.log(event.type)
}

text.AddEventListener('input',logger)

Событие input на элементе inputtext не зависит от количества симоволов, 
а зависит от количества изменений значений элемента

FOCUS

text.AddEventListener('focus',logger)// реагирует, если поставить курсор в поле

BLUR

событие противоположное FOCUS

text.AddEventListener('blur',logger)// отрабатывает в момент потери фокуса

CHANGE 
отрабатывает, когда случается 2 события - input и blur

text.AddEventListener('change',logger)// выводятся input и blur
change срабатывает, когда значение input будет изменено



ЗНАЧЕНИЕ input для value

const span = document.getElementById('text-span')

const logger = function (event) {
    console.dir(event.target.value);
    span.textContent = event.target.value
}
// под полем для инпута будет отображаться то, что написали в инпуте


СОБЫТИЕ keyup/keydown

const text = document.getElementById('text')
const span = document.getElementById('text-span')

const logger = function (event) {
    console.dir(event.type);
    span.textContent = event.target.value
}

text.AddEventListener('keyup',logger)
text.AddEventListener('keydown',logger)
//
keyup/keydown - отрабатывают либо в процессе зажатия клавиши, либо в процессе опускания ы

const span = document.getElementById('range-span')
const range = document.getElementById('range')

const logger = function (event) {
    console.dir(event.type);
    span.textContent = event.target.value
}

text.AddEventListener('input',logger)// пока тянем ползунок на странице - отрабатывает input, как только отпускаем - change 
text.AddEventListener('change',logger)

События можем вещать на элементы напрямую, без создания лишних переменных

document.getElementById('range').addEventListener('change', logger)// сдвинем бегунок и увидим что все работает так же(выводится change)

Но удобнее и лучше класть элемент в переменную, т к она еще может пригодиться в других местах, код читабельнее и лучше 

лучше range.addEventListener('change', logger)\


СОБЫТИЕ DOMContent 
браузерное событие, которое относится к самому DOM

DOMContentLoaded

Отрабатывает только тогда, когда интерпретатор считал верстку и построил на ее основе DOM-дерево 
Вешается сразу на документ 

document.AddEventListener('DOMContentLoaded', function(){
    console.log('DOM построен')
})


СОБЫТИЕ ONBEFOREUNLOAD 
потеряло актуальность 

window.onbeforeloaded = function(){
    return 'Вы уверены, что хотите уйти со страницы?'
}

отрабатывает, когда мы переходим внутри данной вкладки на другую страницу или перезагружаем страницу
Раньше пользовались маркетологи - сейчас на них ставят блокировку 

МЕТОД eventPreventDefault

отменяет стандартное поведение элементов на странице
Пример: стандартное поведение ссылки - открытие другой страницы 

Можно запретить действие и перевести самостоятельно - часто при валидации форм

const link = document.querySelector('a'){
    console.log(link)// оптимизировали с обработчиком событий -- 
    
    link.addEventListener('click', function(event)
        event.eventPreventDefault()// можно кликать скольк угодно, ссылка НЕ откроет другую страницу
        также с помощью этого метода можно запретить открывать меню по клику правой клавиши мыши -->
        console.log('клик по ссылке')
    )
}

    document.addEventListener('contextmenu', function(event){
        event.eventPreventDefault()
        console.log('где меню ')
    })


ВСПЛЫТИЕ И ПЕРЕХВАТ 
всплытие - кликаем по одному элементу, данное событие клика всплывает по его родителям
const btn = document.querySelector('#e_btn')
const circle = document.querySelector('#circle')
const square = document.querySelector('#square')

console.log(btn);
console.log(circle);
console.log(square);

// добавим функцию, которая при клике будет добавлять класс 

const togler = function(event){ 
    event.target.classList.toggle('green')
    console.log(event.target)
    или 
    console.log(current.target)// после клика получим button, потом circle, square
}

btn.addEventListener('click', toggler)
circle.addEventListener('click', toggler)
square.addEventListener('click', toggler)

Специфика работы обработчиков событий - каждый метод обработки событий гарантирует, 
что клик по вложенному элементу кликнет и по всем его родителям 
Событие как бы поднимается навъерх каждый раз на уровень выше и прокликивает каждый элемент родителя 
Всегда можем узнать, какой точно элемент был кликнут из свойства eventTarget


всплытие можно прекратить 
stopPropagation 

const togger = function(event){
    event.stopPropagation()
}

Повернуть всплытие вспять - 
ПОГРУЖЕНИЕ или перехват 

.....
btn.addEventListener('click', toggler, true)
circle.addEventListener('click', toggler)
square.addEventListener('click', toggler) // пошли от родителя к самому кликнутому элементу 




