УРОК 6 - ОБЛАСТИ ВИДИМОСТИ И ЗАМЫКАНИЯ 

ОБЛАСТИ ВИДИМОСТИ - зоны, где задается переменная, станрвится видимой и функция на ней работает
let a = 5; --- находится в глобальной зоне видисоти, все функции о ней знают
function one(){
    console.log(a)
}
one()

если 

let b = 10 ; --- находится в глобальной зоне видисоти, все функции о ней знают
function one(){
    let b = 10

}
one() 
console.log(b) - если написать вне функции - не выведется, ее не видно


Если при объявлении переменной не пишем let const var, тот значение становится видимым глобально.

Когда интерпретатор начинает считывать код, машина перебирает и каждому дает свою зону видимости - при инициализации кода

Если не находит переменную в данной области видимости - идет в родительскую, ищет там. Как только находит, берет ее для своих операций


let a = 5 ; 
function one(){
   let a = 10;
   function two(){
    console.log(a) 
   }
   two();
}
one()  

let a b let b никак не связаны друг с другом. Не знают друг о друге

Внутри каждой функции есть скрытый объект, в кот. указываются все локальные переменные.
Такой объект называется lexical environment  = лексическое окружение. Его никак нельзя вызвать в консоль и посмотреть, что в нем находится .
локальные переменные - переменные, которые указываются локально внутри функции.   


let a = 5;

function one(c, d){
    // lexicalEnvironment = {c: 3, d: undefined}
    let a = 10;
    // lexicalEnvironment = {a:10, c: 3, d: undefined}
    console.log(a,c,d);

    function two(){
        // lexicalEnvironment = {}
        //Scope = {a:10, c:3, d: undefined}
        console.log(a, c)
    }
    two()
}
one(3)


У каждой функции есть второй скрытый объект - scope. Принимает ссылкой все локальные переменные, объявленные в функции родителя. Т е попадает весь lexical environment уровня выше. 
Т е, если не указаны переменные локально, то за значениями функция обращается на уровень ролителя выше, если нет - еще выше и тд = лестница

lexicalEnvironment функции определяется в момент ее вызова, а Scope, как пространство, -  в момент описания функции., когда интерпретатор считывает описание функции. 


let y = 5;

function one(x){
    console.log(x+y);
}

function two (x){
    let y = 15;
    one(3);
}

two()

Ответ 8, тк function one ничего не знает о function two и идет по Scope выше. ВВерх, а не вниз


ЗАМЫКАНИЯ 
Это функция внтри вункции.
 
 function one (x){
    function two() {
        console.log(x);
        console.dir(two);
    }
    two()
 }
 
 one(3)

 Пример сложнее 
 function one (x){
    function two() {
        const a = +prompt("Введите число ")
        x--
        console.log(a);
        console.log(x);

        if(a !== x){
            two()
        }
    }
    two()
 }
 
 one(10)


 X замкнут с функцией, меняется только значение.  

 Когда запускаем фукцию two, то она полностью переопределяет свое тело функции - тело функции возвращается в исходное состояние. Снова определяется переменная a, выводятся логи и проверки. 
 ! При этом значение параметра х не обнуляется к ихначальному. Значение параметра х замкнто ВНЕ функции two. => ЗАМКНУТО с функцией one, ВМЕСТЕ с функцией two.
 Функция two видит это значение и может им как-то пользоваться. Но это значение принадлежит функции one.
Перезапускаясь, функция two не изменит это значение к исходному состоянию. 


Полезная замкнутая функция для url для картинок

function pathGenerator (url) {
    return function (imageName) {
        return url + imageName
    }
}

let urlToIcons = pathGenerator(http....)
let urlToImages = pathGenerator(http....)

console.log(urlToIcons(clock.cvg));
console.log(urlToImages(man.png));