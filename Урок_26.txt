Асинхронный JS
Это код, который отрабатывает не по порядку. 
Пример.

console.log(1);
console.log(2);
console.log(3);
console.log(4);

Вызовы функций будут последовательными. 


console.log(1);
setTimeOut(() => {
    console.log(2);
}, 2000)

console.log(3);
setTimeOut(() => {
    console.log(4);
}, 1000)

Последовательность вызова функций - 1, 3, 4, 2 - это и есть Асинхронный JS


PROMISE

Инструмент 

Promise (Обещание) — это специальный объект в JavaScript, 
который используется для работы с асинхронными операциями (например, запросы к серверу, чтение файлов, таймеры). 
Он помогает избежать "ада колбэков" (callback hell) и делает код более читаемым и управляемым.


const promise = newPromise((resolve, reject) => { // принимает колбек. А колбек принимает resolve и reject
// внутри тела колбека можем совершать асинхронные операции 
    resolve(10)
})
console.log(promise)// в консоли увидим класс promise. У него есть прототип и еще 2 свойства - state (находится в состоянии pending - promise ничего не вернул и он находится в в состоянии ожидания)
-- //выведется state: fulfilled, promiseResult: 10

Проще: 
Когда используем promise, колбек resolve отрабаывает в случае успеха, 
а колбек reject - в случае неудачи, асинхронной операции 


const a = 20,  

const promise = newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(a > 10){
    resolve(a)
        }else{
            reject('some error')
        }
    }, 2000)
    })

promise.then((data) => {
    console.log(data) // а выходит в консоль
}, (errorMess) => {
    console.log(errorMess)
}
)

Полезные свойства объекта в выводе в консоль:
catch
finally 
then - чаще всего пользуются

Метод then (пример чуть выше) отрабатывает только тогда, когда заканчивается асинхронная операция 

метод resolve запускает then и отрабатывает первый колбек

метод reject запускает then и отрабатывает второй колбек, если он передан


Вариант красивее:

const a = 20,  

const promise = newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(a > 10){
    resolve(a)
        }else{
            reject('some error')
        }
    }, 2000)
    })

promise
.then((data) => console.log(data)) // а выходит в консоль
.catch((errorMess) => console.log(errorMess))

Then будет отрабатывать, когда отрабатывает метод resolve, 
метод catch отрабатывает тогда, когда отрабатывает reject

catch

Это метод для перехвата ошибок 
 отрабатывает тогда, когда отрабатывает reject

То что мы передаем в reject перехватывает колбек метода catch

То что мы передаем в resolve принимает колбек метода then

МЕТОД finally 

const a = 20,  

const promise = newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(a > 10){
    resolve(a)
        }else{
            reject('some error')
        }
    }, 2000)
    })

promise
.then((data) => console.log(data)) // а выходит в консоль// цепочка then - then можно вызывать сколько угодно раз 
.catch((errorMess) => console.log(errorMess))
.finally(() => console.log('finally')) 


цепочка then 

promise
.then((data) => {console.log(data)}) // а выходит в консоль// цепочка then - then можно вызывать сколько угодно раз 
.catch((errorMess) => console.log(errorMess))
.finally(() => console.log('finally')) 

Особенность!

promise
.then((data) => data + 10)
.then((newData) => {
    console.log(newData);
})
// вернется результат предыдущего then, т е 30 

!! В этом виде нельзя ничего передать в promise, но МОЖНО, если сделать ее функцией


const promise = (num) => {
newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(num > 10){
    resolve(num)
        }else{
            reject('some error')
        }
    }, 2000)
    })

} 
// Передаем num в resolve и делаем проверку по num

! Передаем значение в promise

promise(15)
.then((dat a) => {console.log(data)}) // выведется ранее переданное в num значение (здесь - 15)
.catch((errorMess) => console.log(errorMess))
.finally(() => console.log('finally')) 

!! МОЖНО СТРОИТЬ promise на promise и возвращать каждый раз асинхронное действие

promise(15)
.then((data) => {
    console.log(data);
return newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(num > 10){
    resolve(num)
        }else{
            reject('some error')
        }
    }, 2000)
    })
    })
// сначала выдаст 15, затем 25


ЕСЛИ НУЖНО ДОЖДАТЬСЯ РЕЗУЛЬТАТОВ ВСЕХ ПРОМИСОВ
return newPromise((resolve, reject) => { 
    setTimeOut(() => {
          if(num > 10){
    resolve(num)
        }else{
            reject('num') // в reject передаем тоже num
        }
    }, 2000)
    })

создадим переменную, в которую занесем результат выполнения промиса со значением 15
во вторую переменную передадим 25

сonst one = promise(15)
сonst two = promise(25)
сonst three = promise(35)

Promise.all([one, two, three])
.then((data) => {
    condole.log(data)
})

.catch(error => console.log(error))

// нужно дождаться каждого промиса и получить единый результат

 МЕТОД promise.all([])

передаем в этот метод каждый промис в массиве и обработать цепочкой then

!НО если хоть в одном промисе мы получаем ошибку, то она попадает в catch 

 МЕТОД FETCH

AJAX
=асинхронный java script и xml 
При этом xml 

FETCH - это замена устаревшему и неудобному xml http request 

FETCH - 1 обязательный парамер - строчка URL запроса 

Пример: 
Внутри файла db.json есть некий объект, в примере это 

{
    "name": "Alex",
    "age": 23

}

Как получить этот объект в методе fetch
Метод получает минимум 1 обязательный аргумент - строчка url запроса

fetch('db.json)
результат выполнения этого метода занесем в переменную 

const user = fetch('db.json)
console.log(user) //

ответ fetch является promise 

Если не настраиваем метод fetch, то получаем по умолчанию по стандарту в request Method: get

это в браузере в разделе fetch/xhr
По стандарту добавляются определенные хедеры 

Так как мы получили promise, то мы можем его обработать 

user.then(response => {
    console.log(response)
})
// получаем в консоли объект response с методами 

!Но если раскроем body, то увидим, что это readableStream
чтобы увидеть объект json, используем метод 

const user = fetch('db.json)
user
.then(response => response.json())
.then(data => {
    console.log(data)
})

можно то же самое, но проще 

fetch('db.json)
    .then(response => response.json())
.then(data => {
    console.log(data)})

.catch(error => {
    console.log(error)
})

СТАТУСЫ 
например в графе fetch/xhr в браузере
При запросе на определенный url, мы получаем СТАТУСЫ
100 и вариации - информационные статусы - встречаются крайне редко 
200 и вариации - успех
300 и вариации - статусы перенаправления - похожи на 200
400 и вариации - ошибки клиентской части 
500 и вариации - ошибки на сервере, backend 

СЕРВИС json placeholder 
 тестовое API
хорошо для изучения тестового fetch

В разделе guide находим строчку, заканчивающуюся на posts, вставляем в метод fetch
обратиться к определенному объекту можно через идентификатор - после posts ставим слеш и пишем номер идентификатора 


fetch('..../posts/1)
    .then(response => response.json())
.then(data => {
    render(data)
    }) // отсюда удобно отправлять данные например для отрисовки на странице 
    идеально для данных, полученных от сервера, откуда инфу хорошо отправлять на рендер

.catch(error => {
    console.log(error)
})


ВТОРОЙ АРГУМЕНТ МЕТОДА fetch 

объект с настройками - необязательный аргумент 
настраиваем метод отправки 
метод POST - отправляет данные на сервер 





fetch('..../posts', {
    method: 'POST',
      body: JSON.stringify({
    title: 'foo',
    body: 'bar',
    userId: 1,
  }),
  headers: {
    'Content-type': 'application/json; charset=UTF-8',
  }, 
})
    .then(response => response.json())
.then(data => {
    console.log(data)
})

.catch(error => {
    console.log(error)
})

body - это тело запроса, объект, который мы будем отправлять 
но не всегда отправляется в JSON формате 

!headers бывают разных типов 
headers и их наличие вообще часто определяется бекэд разработчиком 


ОТПРАВКА ДАННЫХ ИЗ ФОРМЫ 
событие submot отменяет стандартное поведение данных 

Пример: 
const form = document.getElementById('form')

 form.addEventListener('submit', (e) => {
    e.preventDefault()
 })

Как собрать данные из формы 

1) способ 
Получить каждое поле ввода по идентификатору и отправить в виде объекта данные из этих полей 

Пример: 
const form = document.getElementById('form')
const username = document.getElementById('username')
const pass = document.getElementById('password')

 form.addEventListener('submit', (e) => {
    e.preventDefault()

const user = {
    login: username.value,
    password: pass.value 
}
fetch('..../posts', {
      method: 'POST',
  body: JSON.stringify(user),
  headers: {
    'Content-type': 'application/json; charset=UTF-8',
  },
}).then(response => response.json())
.then(data => {
    console.log(data)
})
})

Можно вынести в отдельную функцию логику отправки данных

поале объявления констант


const form = document.getElementById('form')
const username = document.getElementById('username')
const pass = document.getElementById('password')


const sendData = ({url, data = {}, method = 'GET'}) => {
     return fetch('..../posts', {
      method: method ,
  body: JSON.stringify(user),
  headers: {
    'Content-type': 'application/json; charset=UTF-8',
  },
}) 
}
 form.addEventListener('submit', (e) => {
    e.preventDefault()

const user = {
    login: username.value,
    password: pass.value 
}

sendData({
    url: '.../posts',
    data: data,
    method: 'POST'
})
    .then(response => response.json())
    .then(data => {
        console.log(data) 
    })
 })


