УРОК 21. Регулярные выражения 

- это шаблон для поиска совпадений с ним в какой-либо строке 
относятся к объектам

Основные задачи: 
- валидация данных формы - можем контролировать формат вводимых данных
- изменение текстового содержимого блоков на странице, вплоть до изменения верстки

МЕТОДЫ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ 

1) test

const regexp1 = new Regexp("привет")
const regexp2 = /привет/
const str = "привет тебе и всем привет"

console.log(regexp1.test(str)); // передаем строчку str, в которой хотим совершить поиск
// проходится по всей строке const str = "привет тебе и всем привет" в поиске совпадений с шаблоном const regexp1 = new Regexp("привет")
и найдя совпадение вывел true 


console.dir(regexp1);
console.dir(regexp2);

2) exec
проходится по всей строке и находит совпадения с нашим шаблоном 
результат - целый объект со свойствами 

с индексами каждого совпадения 

const regexp1 = new Regexp("привет")
const regexp2 = /привет/
const str = "привет тебе и всем привет"

console.log(regexp1.exec(str)); 


console.dir(regexp1);
console.dir(regexp2);


console.log(regexp1.exec(str)[0]); // нулевой индекс, потому что ищем ПЕРВОЕ совпадение

Gприменяют часто дл выборки из текста всех шаблонных данных - например, всех возможных номеров телефонов


ЧТОБЫ ПОЛУЧАТЬ ВСЕ ВОЗМОЖНЫЕ СОВПАДЕНИЯ В СТРОКЕ, ПОЛЬЗУЕМСЯ ФЛАГАМИ 
РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ 

каждый флаг пишется после самого шаблона 

const regexp1 = new Regexp("привет", "g") // где g - флаг


в случае, если работаем с литералами, флаги указываются после последнего литерала 

const regexp2 = /привет/g


g - означает, что мы будем проводить поиск глобально по всей строке

не обязательно только первое - можем искать ВСЕ совпадения 


const regexp1 = new Regexp("привет")
const regexp2 = /привет/
const str = "привет тебе и всем привет"

console.log(regexp1.exec(str)); 
console.log(regexp1.exec(str)); 
console.log(regexp1.exec(str)); 
console.log(regexp1.exec(str)); 
console.log(regexp1.exec(str)); 

console.dir(regexp1);


Суть: в свойствах объекта есть свойство last index - в нем отображается последний символ слова, которое совпалдо и искомым
Есть index, который выводит порядковый номер первого совпавшего символа. 

По слову и строке привет - на первом выводе консоль index = 0 (это первый символ в строке по порядку)
last index - 6 (так же по порядку)

На следующем выводе в консоль index уже будет 19(условно), last index 26(условно)
и тд. в каждом новом выводе первый символ (индекс) является окончанием второго, 
а ласт индекс - окончание искомого слова и оно же начало нового поиска.

Так происходит пока не закончится строка/объект и все не начнется с начала - тогда будет null,
а при следующей консоли все повторится 

Подходящие варианты по поиску можно собирать в массив для удобства 

let reg // переменная, куда будет заноситься каждый очередной метод exec 

reg = regexp1.exec(str);

запускаем цкил while - проверяем, не лежит ли в этой переменной null

Если лежать не будет - то снова переопределяем переменную reg 

reg = regexp1.exec(str)
while (reg) {
    console.log(regexp1.exec(str));
    reg = regexp1.exec(str)// это случай с индексом 0, выводим переменную до ее переопределения 
    
}

!!!важно переопределять(обнулять поиск) переменную

Пример: 

let reg
const arr =[]
reg = regexp1.exec(str);
while (reg) {
    arr.push([0])// здесь
    reg = regexp1.exec(str);
}

console.log(arr);

!!На практике метод test встречается чаще чем exec


ФЛАГ I

Игнорирует регистр совпадения


ХИТРОСТЬ 
можем заменить переменную на значение (в консоли)
тогда не будет ломаться last index

const str = "kuckoo@gmail.com"

console.log(/привет/gi.test(str));


строчку с маилом могли получить откуда угодно - например, из поля ввода при отправке формы


МЕТОДЫ ДЛЯ СТРОК, КОТОРЫЕ РАБОТАЮТ С РЕГУЛЯРНЫМИ ВЫРАЖЕНИЯМИ 

МЕТОД search 

str.search()
внутрь метода передаем регулярку

const str = "Привет тебе, привет ему и ей привет!"

console.log(str.search(/привет/));
// в консоли индекс 13. Этот индекс - начало совпадения с нашим шаблоном
Если не найдет совпадений - вернет -1



МЕТОД match 

Находит в строке все возможные варианты и складирует их в массив
похож на метод exec, но проще 


const str = "Привет тебе, привет ему и ей привет!"
console.log(str.search(/привет/gi));
// вернет массив из приветов 


!МЕТОД replace
Принимает регулярное выражение и через запятую указываем, на что меняем каждое совпадение в строке

const str = "Привет тебе, привет ему и ей привет!"
console.log(str.replace(/привет/gi, "hello"));
console.log(str.replace(/привет/gi, ""));// можно так, тогда нежелательное вырежется и останется пустое место 


!СИМВОЛЬНЫЕ КЛАССЫ 

спец обозначения, которые соответствуют любому символу из определенного набора

\d - любая цифра
\w - любая латинская буква, цифра или нижнее подчеркивание - КИРИЛЛИЦУ НЕ ВОСПРИНИМАЕТ
\s - любой пробельный символ: пробел, перенос строки или табуляция 


const phone = ' 8(344) 444 - 55 - 66'

console.log(phone.match(/\d/g));// в консоли получим массив со всеми цифрами номера 

можем использовать метод join 

console.log(phone.match(/\d/g).join(''));// выведет обычный номер телефона 
console.log(phone.match(/\w/g).join('')); - такой же результат, но если в передаваемом номере окажется буква, а вывести нужно только цифры, то выведет цифры вместе с буквами


АНТОНИМЫ ЭТИХ СИМВОЛОВ 

\D - любой символ кроме \d 
\W - любой символ кроме \w 
\S - любой символ кроме \s 

(точка)\. - вообще любой символ кроме \n (кроме переноса строки)

Пример: 

const phone = ' 8(344) 444 - 55 - 66с'

console.log(phone.replace(/\S/g, "*"));// все символы кроме пробелов стали звездочками


Существует 2 способа:
1)Конструкции

const regexp1 = new Regexp("привет")

console.dir(regexp1)
console.dir(regexp2)




2) Литералы 


ЯКОРЯ 
то, что скажет о начале и конце строки

^ - начало строки
$ - конец строки
\b - граница слова

Пример:
const date = '22 october 1987'
console.log(date.match(/\d\d/g))// получим 22 19 и 87

если console.log(date.match(^/\d\d/g))// получим только 22 

НАБОРЫ И ДИАПАЗОНЫ

если хотим получить из строки оба слова 

const string = 'дедушка и девушка'
console.log(string.match(/де[дв]ушка/g))// получаем оба слова 

[дв] - это действие называется набор 


 
ДИАПАЗОНЫ

в [] можем передать диапазон символовь


const string = 'дедушка и девушка'
console.log(string.match(/де[а-я]ушка/g))// получаем оба слова в нижнем регистре

В диапазон можно передавать латинские буквы, заглавные буквы без пробелов и запятых, цифры 

const string = 'де6ушка и девушка'
console.log(string.match(/де[a-zA-Z0-9]ушка/gi))// выведет дедушка, тк есть цифра

У ДИАПАЗОНОВ СУЩЕСТВУЮТ ОТРИЦАНИЯ 

const string = 'дедушка и девушка'
console.log(string.match(/де[^a-zA-Z0-9]ушка/gi))

символы д и в не входят ни в один из диапазонов 

^ - знак отрицания внутри диапазонных групп и наборов
Ищем любые символы не подходящие под данные диапазоны 

пример с диапазоном 
console.log(string.match(/де[^гшщ]ушка/gi))
ищем все что не является или г или ш или щ


ЭКРАНИРОВАНИЕ СИМВОЛА - /^

Можно экранировать любой символ

console.log(string.match(/де[/^]ушка/gi))

СТРОКА(КАВЫЧКИ) СЪЕДАЮТ ЭКРАНИРОВАНИЕ

 РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ, СОЗДАННЫЕ ЧЕРЕЗ КОНСТРУКТОР

const string = 'де^ушка и девушка'
const reg = new RegExp("де[/^]ушка", "gi)
console.log(string.match(/де[/^]ушка/gi));// выведет де^ушка
console.log(reg);// выведет оба слова 

Если хотим передать только де^ушка

const string = 'де^ушка и девушка'
const reg = new RegExp("де[\\^]ушка", "gi)// добавили еще одно экранирование и получили де^ушка
console.log(string.match(/де[/^]ушка/gi));// выведет де^ушка

console.log(string.match(reg));// выведет оба слова 


КВАНТИФИКАТОРЫ 

const string = 'дедушка и девушка'

console.log(string.match(/де[дв]ушка/gi))

Эти слова отличаются двумя символами до и 3 после

--> console.log(string.match(/[а-я]{2}[дв][а-я]{4}/gi)) // получаем девушка и дедушка 

{2} - квантификатор, отражает количество необходимых символов
можно указать диапазон

/ {1} + диапазон от 1 до бесконечности

/ {0,} * диапазон от 0 до бесконечности или символ звездочки *
/{0,1} ? диапазон от 0 до 1, обозначается ? делает символ не обязательным - может быть, а может и не быть

СКОБОЧНЫЕ ГРУППЫ 
Любой отрезок регулярного выражения мы можем ограничить круглыми скобками 

И использовать квантификаторы на всем выражении внутри круглых скобок 

const string = 'google.com site.google.com'

console.log(string.match(/([\w]+\.)+[w]+/gi)) / \. - экранируем точку, чтобы ее тоже вывели 

// получаем полное доменное имя, включая поддомены. Даже если поддоменов будет гораздо больше 

ПРИМЕР С ИМЕЙЛОМ 

const string = 'test-test.test@google.com'

console.log(string.match(/[\-\.\w]+@([\w]+\.)+[w]+/gi)) \\готовая проверка на имейл адрес 

первый \w - первая часть, до @
c + потому что символов может быть сколько угодно

В адресах имейл разрешены тире и точки. Чтобы их учесть, можно использовать набор из разрешенных символов
 и после этого поставить плюс 

экранируем тире и точку 

const string = 'test-test.test@google.com'

const testEmail = /[\-\.\w]+@([\w]+\.)+[w]+/gi

console.log(testEmail.test(string)) // это проверка на валидность, в консоли будет true 


РАЗБИТИЕ ВСЕГО РЕГУЛРНОГО ВЫРАЖЕНИЯ НА УЧАСТКИ И ИСПОЛЬЗОВАНИЕ ИХ В ПОСЛЕДУЮЩЕЙ ФУНКЦИИ

const string = 'test-test.test@google.com'

const testEmail = /([\-\.\w]+)@([\w]+\.)+[w]+/gi

const result = string.replace(testEmail, (str, $1) => {
    return "email "+ str
} )

console.log(result)



 $1 - знак доллара и последующая цифра обозначают часть выражения в скобках и выводится в консоль будет именно только эта часть в скобках




