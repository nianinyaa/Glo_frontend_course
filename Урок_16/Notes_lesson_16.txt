Урок 16. Особенности современного стандарта ES6

let const var 

Переменная, заданная через var, определяется в глобальном объекте 

let и const определяют переменную внутри области видимости и не записывают ее в глобальный объект 

var записывает переменную внутри глобальной области видимости, то есть в глобальном объекте window
и сразу выдает ей необходимое значение 

у этой переменной сразу определяется необходимое значение 

Ключевое слово let определяет изменяемая Переменная (переопределяется  ) 

Если определяем через const, то переопределить значение невозможно
НО!  В массив, созданный через const, можно добавить пушем новые элементы. Изменить - нельзя, а добавить можно

так же и с объектами 


СТРЕЛОЧНЫЕ ФУНКЦИИ 

 Главное преимущество - полное отсутствие собственного контекста вызова 
Для контекста вызова они как решето 
Берет контекст из элемента уровня выше  

Если все методы функции будут написаны стрелочной нотацией, то проблем с контекстом вызова не возникнет
В каждой функции в каждом методе контекст вызова будет ссылаться на сам объект 
Получаем объект как контекст вызова 

Значения параметров можно указывать по умолчанию   
const foo(name, age = 20) => {
  .....тело функции 
}

foo('Alex'); 


ИНТЕРПОЛЯЦИЯ (ШАБЛОННЫЕ СТРОКИ)

дано:

const foo(name, age = 20) => {

console.log('Привет, меня зовут ' + name + '!');
console.log('Мне' + age + 'года!');
}
  
foo('Alex')

стало:(перенесли в 1 строчку консоли)
  
const foo(name, age = 20) => {

console.log('Привет, меня зовут ' + name + '!' \n 
'Мне' + age + 'года!'); 
}
foo('Alex')

\n знак переноса строки 


Еще вариант - обратные кавычки, бектики

const foo(name, age) => {

console.log('Привет, меня зовут ${name} + ! \n 
Мне + ${age} + года!'); 
}
foo('Alex, 33')

Внутри { } можем делать вычисления и выражения


ОПЕРАТОРЫ rest и spread (остаточный параметр и оператор расширения)

  

ОПЕРАТОР rest 

функция отобразит лишь те элементы, которые есть в круглых скобках - остальные не выведутся 

const sum = (a,b,c) => {
  console.log(a);
  console.log(b);
  console.log(c);
}

sum(1,2,3,4,5) // выведутся только первые 3  
  
  
const sum = (a,b,c ...params) => {
  console.log(a);
  console.log(b);
  console.log(c);
  console.log(params);
}

sum(1,2,3,4,5) 
главное, чтобы ...params были последним элементом в перечислении 


можно получить сумму ВСЕХ элементов 

const sum = (...params) => {
  return params.reduce((sum,num) = > sum + num)
}

console.log(sum(23,44,12,17)); 



ОПЕРАТОР spread 
Позволяет быстро и легко соединять разные массивы  

 // выведется сумма всех элементов из каждого массива 

Также можно добавлять новые элементы в любое место массива 

const firstAr = [1,2,3,4,5]
const secondAr = [6,7,8,9,10]
console.log([55, 23, ..firstAr, 46, 98, ...secondAr])


КЛАССЫ 

ФУНКЦИИ-КОНСТРУКТОРЫ 
можно записывать constructor как класс или как функцию 

1) const Person1 = function(name, age){
  this.name = name
  this.age = age
}

const person1 = new Person1('Vlad', 21)
console.log(person1);

class Person {
  costructor(name,age){
    tnis.name = name
    this.age = age
  }
}

const person = new Person('Vlad', 21)
console.log(person);


// в консоль выводится одно и то же - разница в том, как выводится прототип в обоих случаях. в 1) - costructor - это функция f(name, age)
во 2) costructor - class Person

ПРИВЯЗКА МЕТОДОВ К ФУНКЦИИ-КОНСТРУКТОРУ

1)   указать внутри функции-конструктора (плохо для производительности)
2) указать снаружи, привязав к прототипу   

Есть 3) подход - самый лучший. Он объединяет лучшие стороны первых 2 подходов. Что дает?  

- методы указываем внутри сущности родителя, т е внутри класса  
- получаем доступ к использованию скрытых переменных 
- одновременно это метод привязывается сразу к прототипу    


 class Person {
    constructor(name, age){
      this.name = name
      this.age = age 
    }
sayHello(){
  console.log(`Привет! Меня зовут ${this. name}`)
}
}

const person = new Person('Vlad', 21)
person.sayHello(); 
console.log(person);


СКРЫТЫЕ ПЕРЕМЕННЫЕ
статические переменные 

class Person {
    constructor(name, age){
      this.name = name
      this.age = age 
    }

static count = 0 // переменная, созданная внутри класса - статическая, т е доступна общему классу
но экземплярам класса недоступна      

sayHello(){
  console.log(`Привет! Меня зовут ${this. name}`)
}
}

const person = new Person('Vlad', 21)
person.sayHello(); 
console.log(person);


статические методы 

class Person {
    constructor(name, age){
      this.name = name
      this.age = age 
      Person.incrementCount()  
    }

static count = 0 // переменная, созданная внутри класса - статическая, т е доступна общему классу
но экземплярам класса недоступна     

static getCount (){
  return Person.count // сделать переменную, которая будет возвращать значение count. 
    
}

static incrementCount(){ //этот метод при каждой инициализации нового объекта на основе прототипа нашего класса будет увеличивать count на единицу 
и будем вызывать этот метод каждый раз при инициализации контруктора  
  Person.count++
}



sayHello(){
  console.log(`Привет! Меня зовут ${this. name}`)
}
}

const person = new Person('Vlad', 21)
person.sayHello(); 
console.log(Person.getCount( ));



статические методы и переменные записываются не в объект, а напрямую в конструктор. не принадлежат создаваемым объектам на основе данного класса 
  


НАСЛЕДОВАНИЕ КЛАССОВ 
  

class Person {
    constructor(name, age){
      this.name = name
      this.age = age
    }
sayHello(){
  console.log(`Привет! Меня зовут ${this. name}`)
}

}


class FrontEndDev extends Person{ // создается элемент, который наследует чеерез extends свойства у массива Person
   
}

const dev = new FrontEndDev('Vlad', 23)
console.log(dev)
dev.sayHello()


МЕТОД super (чтобы связать 2 конструктора)
это связующее звено между классом-наследником и классом-прототипом  (между классом FrontEndDev и классом Person. Метод super передает в метод Person name age    ) 

//расширим класс FrontEndDev, создадаим свой конструктор
class FrontEndDev exteds Person {
   constructor(name, age,   skills = []){
    super(name, age)// метод super передает в метод constructor необходимые парамеры 
    this.skills = skills  
   }
}
const dev = new FrontEndDev('Vlad', 23)
console.log(dev)
dev.sayHello()  


ЧЕРЕЗ МЕТОД super МОЖНО ОБРАТИТЬСЯ К МЕТОДАМ РОДИТЕЛЬСКОГО КЛАССА  

сlass FrontEndDev exteds Person {
   constructor(name, age,   skills = []){
    super(name, age)// метод super передает в метод constructor необходимые парамеры 
    this.skills = skills  
   }

  test(){
    super.sayHello( )
  }

// это метод test, который при вызове запустит  метод sayHello, который принадлежит super 
}

const dev = new FrontEndDev('Vlad', 23)
console.log(dev)
dev.sayHello()  
dev.test() // отработает метод sayHello, который принадлежит person 



ГЕТТЕРЫ И СЕТТЕРЫ 
базовый инструмент в framework, view 

Это методы для работы со свойствами объекта 
Либо выдвет какую-то информацию в определенном виде 
Либо записывают информацию непосредственно в объект 
Работают только со свойствами, у которых в имени есть нижнее подчеркивание - значит, что свойство создано только для чтения, напрямую это свойство менять нельзя  


Геттер объявляется ключевым словом get 
всегда что-то возвращает 

сlass FrontEndDev exteds Person {
   constructor(name, age,   skills = []){
    super(name, age)// метод super передает в метод constructor необходимые парамеры 
    this._skills = skills  
   }

get skills(){
  return this._  skills 
}

set skills (str){
  this.skills.push(str )
}

}
const dev = new FrontEndDev('Vlad', 23)
dev.skills = 'Первое  свойство'
console.log(dev)

Сеттер  
Получает элемент 
Мы передаем в него определенные данные и он записывает их так, как нам нужно. 
Полностью контролируем процесс.

На сеттерах и геттерах постороено многое во view - упрощает работу 


ДЕСТРУКТУРИЗАЦИЯ 
объектов и массивов
сокращает код 

ДЕСТРУКТУРИЗАЦИЯ объектов

const user = {
  name: 'Alex',
  age: 33,
  isAuth: false
  projects: {
    firstProject: 'firstProject',
    secondProject: 'secondProject',
  }



}

уже деструктурированный вариант(выводит не каждое совйство по отдельности через каждую отдельную переменную)

const {name, age, isAuth} = user;
console.log(name)

или задать значение свойства в самой переменной, если нужно

const{name: nameUser, age, isAuth, projects: {firstProject, secondProject}} = user; 
console.log(nameUser)
console.log(firstProject )

ДЕСТРУКТУРИЗАЦИЯ массивов 
обращаться через создание новых переменных и индексов массивов неудобно 

const names = ['Artyom', 'Max', 'Vasya', ['Petya', 'Alex']]
const [art, max, vasya, [petya, alex] ] = names
console.log(art);
console.log(max);
console.log(vasya);
console.log(other);

вложенности так же 