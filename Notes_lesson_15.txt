Урок 15. ООП, наследование 

ООП = объектно-ориентированное программирование 

1 подхода в js
1) функциональный. пишем функции и пользуемся ими 
2) объектно-ориентированный


JS =  прототипно-ориентированный язык программирования 
  
Прототип - скрытая ссылка объекта 
Прототип - объект, из которого текущий объект берет недостающие свойства и методы

Доступ к прототипу: 
let arr = [1,2,3,4,5]

console.log(arr.__proto__);

В консоль выйдет сам прототип нашего массива 

Создавать массивы можно через конструкцию array  
Это специальная функция конструктора, которая наделяет объект определенными свойствами и методами 

Когда создается массив arr, он проходит через функцию конструктор array, которая наделяет его своим прототипом. Поэтому наш arr получает прототип именно от конструктора array

  
КАК РАБОТАЕТ ПРОТОТИП, САМОЕ ПРОСТОЕ ОБЪЯСНЕНИЕ 

const man = {
  hands: 2,
  legs: 2,
  eyes: 2,
  walk: function(){
    console.log('Я хожу')
  },
  talk: function(){
    console.log('Я говорю ')
  }
} 


создаем новую пременную с помощью метода object.create, в который передаем тот шаблон, на основе которого будем создавать новый объект 
 

const newMan = Object.create(man)// если вывести в консоль, то будет пустой массив 
//используем метод пустого объекта
newMan.walk
// в консоли будет 'Я хожу', потому что у объекта появилась ссылка на его прототип - ссылка на объект man, у которого есть шаблонные свойства 

Новый человек создан по образу и подобию прототипа man  - значит, ему присущи все характеристики самого прототипа 

// добавимм уникальности 

newMan = 'Ivan'
newMan.age = 23

const newWoman = Object.create(woman)
newWoman.name = 'Anna'
newWoman.age = 22
  
console.log(newMan)
console.log(newWoman)

Получили двух разных людей, но прототип у них один, он одинаковый 

Построены на основе базовых характеристик прототипа, но они являются уникальными 


МЕТОД hasOwnProperty
Передаем в него свойства, которые хотим проверить 
Возвращает булевое значение 
Проверяет, есть ли у объекта это свойство, ИГОРИРУЯ его прототипы


.....куча других свойств и методов прототипов 
developer1.name = 'Alex'
developer2.name = 'Nina'
developer3.name = 'Kate'
developer4.name = 'Dan'

console.log(developer1.hasOwnProperty('name')); // в консоли true 
 
console.log(developer1.hasOwnProperty('role')); // в консоли false(потому что его нет у этого объекта, а есть только в его прототипе)
получаем через обращение к прототипу  

console.log(developer1.__proto__.hasOwnProperty('role')); // true   
   
//еще одно свойство
console.log(developer1.__proto__.hasOwnProperty('workplace')); // false, но можем найти его в прототипе ниже по уровню 

console.log(developer1.__proto__. __proto__.hasOwnProperty('workplace  ')); // true   

МЕТОД, проверяющий, является ли 1 объект прототипом другого объекта -- .isPrototypeOf()  

...куча свойств и методов 

 console.log(frontEndDev.isPrototypeOf(developer3))


 ФУНКЦИИ-КОНСТРУКТОРЫ 

Оптимизируем, чтобы не создавать кучу одинаковых переменных, отличающихся только значением 

Один раз опишем функцию-конструктор и на ее основе, вызывая ее, получать сколько угодно подобных объектов 

Функция-конструктор = любая функция, использующая оператор new для создания новой сущности

Функция-конструктор пишется с большой буквы 

const Person = function (name){
  this.name = name
  return this //  возвращается тот объект, который был пустым, но которому Функция-конструктор приписала новые свойства   
}

const person1 = new Person('Vlad')
const person1 = new Person('Alex')
const person1 = new Person('Ivan') 

console.log(person1)
console.log(person2)
console.log(person3)


 Сама Функция-конструктор - это абстракция, описание будущего объекта, который мы будем создавать на основе данного конструктора 

ОТЛИЧИЯ Функции-конструктора от обычной функции 

1) Функция-конструктор всегда вызывается через оператор new, в (аргумент)

   Если передавать его не будем, то можно не указывать круглые скобки, объект будет создан, но имя - undefined 

  
Когда интерпретатор считает new, то в памяти интерпретатора будет создан пустой объект!
Далее вызывается функция, а новому пустому объекту перенаправляется контекст вызова this 

Т е контекст вызова самой Функцияи-конструктора перенаправляется на новосозданный пустой объект 

Далее данному объекту приписываются те свойства, которые мы описали в функции-конструкторе 

Затем Функция-конструктор возвращает новый объект     

Если мы писали аргуменрты ('Vlad'), то они попадают в параметры функции function (name) и подставляются как значения нужным свойствам - this.name = name 

Функция-конструктор возвращает объект и кладет в ту переменную, которую мы создали 



В прототип можем добавлять любое количество новых методов  

  const Person = function (name){
  this.name = name
}

Person.prototype.sayHello = function (){
   console.log('Привет, меня зовут '+ this.name ');  // добавили метод sayHello в прототип 
}

Методы можно указывать и внутри функции-конструктора в зависимости от целей -- будет создан объект, наделенный и свойством и методом

Но они будут принадлежать и дежать не в прототипе, а именно в этом объекте 

Преимущество записи внутри  функции-конструктора - доступ к скрытым переменным    


const Person = function (name){
  this.name = name

const age = 33

}

Person.prototype.sayHello = function (){
   console.log('Привет, меня зовут '+ this.name ');  // добавили метод sayHello в прототип 
}
  
Мы нигде кроме нашего объекта или конструктора увидеть данную переменную не можем.
Ее можно переопределить, как любое свойство объекта 

У подхода описывать метод внутри функции-конструктора есть НЕДОСТАТОК  
На основании данного конструктора мы можем создавать сотни разных объектов и у каждого объекта будет свой собственный метод sayHello 
Они не будут равны, это будут совсем разные методы  

Лучше создаввать через прототип конструктора, а не внутри конструктора   
Плюс метода навешивание метода на прототип  - выигрываем в производительности 
НО!  Теряем возможность использовать скрытые переменные внутри функции-конструктора 

Можем СОЗДАТЬ СКРЫТУЮ ПЕРЕМЕННУЮ ВНУТРИ МЕТОДА - вариант не очень 

РЕКОМЕНДАЦИЯ вешать новые методы на ПРОТОТИП 
  

prototype.isPrototypeOf()
позволяет точно узнать, является ли 1 элемен прототипом другого
  
console.log(Person.prototype.isPrototypeOf(person1))
   
не оч, лучше аналог - оператор instanceOf(  )
console.log(person1 instanceof Person)

читается: зависит ли person1 от конструктора Person
    

НАСЛЕДОВАНИЕ

const Person = function(name){
   this.name = name
}

Person.prototype.sayHello = function (){
  console.log('Привет, меня зовут ' + this.name);
}

const Student = function (name, role){
  this.role = role
}

const newStudent = new Student('Vlad', 'student')

console.log(newStudent )



Создали новую сущность, которая является прототипом функции-консруктора student
и передали 2 аргумента - имя и роль 








